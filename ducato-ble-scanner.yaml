# ============================================================
# ESPHome - BLE Scanner zum Finden des OBD2 BLE Dongles
# Hardware: M5Stack ATOM S3 (ESP32-S3)
# ============================================================
#
# Dieser Scanner arbeitet in zwei Phasen:
#
# PHASE 1 - Geräte finden (Advertising Scan):
#   Scannt nach allen BLE-Geräten und gibt MAC-Adresse,
#   Name und Service-UUIDs im Log aus.
#   → Damit findest du die MAC-Adresse deines Dongles.
#
# PHASE 2 - Characteristics auslesen (GATT Discovery):
#   Verbindet sich mit dem Dongle und listet alle GATT
#   Services und Characteristics mit Properties auf.
#   → Damit findest du die TX- und RX-UUIDs.
#
#   TX (Write):   Characteristic mit WRITE Property
#   RX (Notify):  Characteristic mit NOTIFY Property
#
# Anleitung:
#   1. Diese Config flashen (Phase 1 läuft sofort)
#   2. OBD2 Dongle in OBD-Port stecken (Zündung an)
#   3. ESPHome Logs beobachten
#   4. Nach dem Dongle-Namen suchen (z.B. "IOS-Vlink",
#      "V-LINK", "OBDII", "Veepeak", "KONNWEI", etc.)
#   5. MAC-Adresse notieren
#   6. MAC-Adresse unten bei ble_client eintragen
#   7. Erneut flashen → Phase 2 startet automatisch
#   8. Service-UUIDs und Characteristic-UUIDs aus dem Log
#      notieren (TX = WRITE, RX = NOTIFY)
#   9. Die gefundenen Werte in die Haupt-Config übernehmen
# ============================================================

esphome:
  name: ducato-ble-scanner
  friendly_name: "BLE OBD2 Scanner"

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: arduino

logger:
  level: VERBOSE

# Kein API/OTA nötig für den Scan, aber WiFi zum Log-Streaming
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  ap:
    ssid: "BLE-Scanner-Fallback"
    password: "scanner123"

captive_portal:

web_server:
  port: 80

# =============================================================
# PHASE 1 - BLE Advertising Scanner
# =============================================================
# Scannt aktiv nach allen BLE-Geräten und loggt sie.
# Läuft immer, auch wenn Phase 2 aktiv ist.
esp32_ble_tracker:
  scan_parameters:
    active: true
    interval: 100ms
    window: 99ms
  on_ble_advertise:
    - lambda: |-
        // Alle gefundenen Geräte loggen
        ESP_LOGI("ble_scan", "========================================");
        ESP_LOGI("ble_scan", "BLE Geraet gefunden:");
        ESP_LOGI("ble_scan", "  Name: %s", x.get_name().c_str());
        ESP_LOGI("ble_scan", "  MAC:  %s", x.address_str().c_str());
        ESP_LOGI("ble_scan", "  RSSI: %d dBm", x.get_rssi());

        // Service UUIDs ausgeben
        for (auto uuid : x.get_service_uuids()) {
          ESP_LOGI("ble_scan", "  Service UUID: %s", uuid.to_string().c_str());
        }

        // Manufacturer Data ausgeben
        for (auto mfr : x.get_manufacturer_datas()) {
          std::string hex;
          for (auto b : mfr.data) {
            char buf[4];
            snprintf(buf, sizeof(buf), "%02X ", b);
            hex += buf;
          }
          ESP_LOGI("ble_scan", "  Manufacturer: UUID=%s Data=%s",
                   mfr.uuid.to_string().c_str(), hex.c_str());
        }
        ESP_LOGI("ble_scan", "========================================");

# =============================================================
# PHASE 2 - GATT Characteristic Discovery
# =============================================================
# Verbindet sich mit dem Dongle und liest alle Services und
# Characteristics aus. Aktiviere Phase 2, indem du die
# MAC-Adresse deines Dongles unten einträgst.
#
# ⚠ WICHTIG: Trage hier die MAC-Adresse deines Dongles ein!
#   Die MAC findest du im Log von Phase 1.
#
# Zum Aktivieren: Ersetze AA:BB:CC:DD:EE:FF mit der echten MAC
# und entferne die Kommentarzeichen (#) vor den folgenden Zeilen:

#ble_client:
#  - mac_address: "AA:BB:CC:DD:EE:FF"
#    id: obd_scanner_client
#    on_connect:
#      then:
#        # Kurz warten bis Service Discovery abgeschlossen ist
#        - delay: 3s
#        - lambda: |-
#            // ============================================================
#            // GATT Characteristic Discovery
#            // Liest alle Services und Characteristics des Dongles aus
#            // ============================================================
#            ESP_LOGI("ble_char", "");
#            ESP_LOGI("ble_char", "############################################################");
#            ESP_LOGI("ble_char", "# GATT Characteristic Discovery gestartet");
#            ESP_LOGI("ble_char", "############################################################");
#            ESP_LOGI("ble_char", "");
#
#            auto *ble_client = id(obd_scanner_client);
#
#            // GATT-Datenbank vom ESP-IDF abfragen
#            // Erster Aufruf: Anzahl der Einträge ermitteln
#            uint16_t count = 0;
#            esp_gattc_db_elem_t *db = nullptr;
#            esp_err_t ret = esp_ble_gattc_get_db(
#                ble_client->get_gattc_if(),
#                ble_client->get_conn_id(),
#                0x0001, 0xFFFF, nullptr, &count);
#
#            if (count == 0) {
#                ESP_LOGW("ble_char", "Keine GATT-Eintraege gefunden!");
#                ESP_LOGW("ble_char", "Moegliche Ursachen:");
#                ESP_LOGW("ble_char", "  - Service Discovery noch nicht abgeschlossen");
#                ESP_LOGW("ble_char", "  - Dongle antwortet nicht");
#                return;
#            }
#
#            ESP_LOGI("ble_char", "Anzahl GATT-Eintraege: %d", count);
#            ESP_LOGI("ble_char", "");
#
#            // Buffer allozieren und Datenbank erneut abfragen
#            db = (esp_gattc_db_elem_t *)malloc(sizeof(esp_gattc_db_elem_t) * count);
#            if (db == nullptr) {
#                ESP_LOGE("ble_char", "Speicher-Allokation fehlgeschlagen!");
#                return;
#            }
#
#            ret = esp_ble_gattc_get_db(
#                ble_client->get_gattc_if(),
#                ble_client->get_conn_id(),
#                0x0001, 0xFFFF, db, &count);
#
#            if (ret != ESP_OK) {
#                ESP_LOGE("ble_char", "GATT DB Abfrage fehlgeschlagen: %d", ret);
#                free(db);
#                return;
#            }
#
#            // Durch alle GATT-Einträge iterieren und loggen
#            std::string current_service_uuid = "";
#
#            for (uint16_t i = 0; i < count; i++) {
#                auto &elem = db[i];
#
#                if (elem.type == ESP_GATT_DB_PRIMARY_SERVICE ||
#                    elem.type == ESP_GATT_DB_SECONDARY_SERVICE) {
#                    // --- Service gefunden ---
#                    char uuid_str[64];
#                    if (elem.uuid.len == ESP_UUID_LEN_16) {
#                        snprintf(uuid_str, sizeof(uuid_str), "0x%04X", elem.uuid.uuid.uuid16);
#                    } else if (elem.uuid.len == ESP_UUID_LEN_32) {
#                        snprintf(uuid_str, sizeof(uuid_str), "0x%08lX", (unsigned long)elem.uuid.uuid.uuid32);
#                    } else if (elem.uuid.len == ESP_UUID_LEN_128) {
#                        uint8_t *u = elem.uuid.uuid.uuid128;
#                        snprintf(uuid_str, sizeof(uuid_str),
#                            "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
#                            u[15],u[14],u[13],u[12],u[11],u[10],u[9],u[8],
#                            u[7],u[6],u[5],u[4],u[3],u[2],u[1],u[0]);
#                    }
#                    current_service_uuid = uuid_str;
#
#                    ESP_LOGI("ble_char", "========================================");
#                    ESP_LOGI("ble_char", "SERVICE: %s", uuid_str);
#                    ESP_LOGI("ble_char", "  Handle: 0x%04X", elem.attribute_handle);
#                    ESP_LOGI("ble_char", "----------------------------------------");
#
#                } else if (elem.type == ESP_GATT_DB_CHARACTERISTIC) {
#                    // --- Characteristic gefunden ---
#                    char uuid_str[64];
#                    if (elem.uuid.len == ESP_UUID_LEN_16) {
#                        snprintf(uuid_str, sizeof(uuid_str), "0x%04X", elem.uuid.uuid.uuid16);
#                    } else if (elem.uuid.len == ESP_UUID_LEN_32) {
#                        snprintf(uuid_str, sizeof(uuid_str), "0x%08lX", (unsigned long)elem.uuid.uuid.uuid32);
#                    } else if (elem.uuid.len == ESP_UUID_LEN_128) {
#                        uint8_t *u = elem.uuid.uuid.uuid128;
#                        snprintf(uuid_str, sizeof(uuid_str),
#                            "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
#                            u[15],u[14],u[13],u[12],u[11],u[10],u[9],u[8],
#                            u[7],u[6],u[5],u[4],u[3],u[2],u[1],u[0]);
#                    }
#
#                    // Properties dekodieren
#                    uint8_t props = elem.properties;
#                    std::string prop_str = "";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_READ)       prop_str += "READ ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_WRITE_NR)   prop_str += "WRITE_NO_RESP ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_WRITE)      prop_str += "WRITE ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_NOTIFY)     prop_str += "NOTIFY ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_INDICATE)   prop_str += "INDICATE ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_BROADCAST)  prop_str += "BROADCAST ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_AUTH)       prop_str += "AUTH ";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_EXT_PROP)   prop_str += "EXT_PROP ";
#
#                    // Hinweis für TX/RX Erkennung
#                    std::string hint = "";
#                    if (props & ESP_GATT_CHAR_PROP_BIT_NOTIFY)     hint = " << vermutlich RX (Daten empfangen)";
#                    if ((props & ESP_GATT_CHAR_PROP_BIT_WRITE) ||
#                        (props & ESP_GATT_CHAR_PROP_BIT_WRITE_NR)) {
#                        if (!(props & ESP_GATT_CHAR_PROP_BIT_NOTIFY)) {
#                            hint = " << vermutlich TX (Befehle senden)";
#                        } else {
#                            hint = " << TX+RX (bidirektional)";
#                        }
#                    }
#
#                    ESP_LOGI("ble_char", "  CHARACTERISTIC: %s", uuid_str);
#                    ESP_LOGI("ble_char", "    Handle:     0x%04X", elem.attribute_handle);
#                    ESP_LOGI("ble_char", "    Properties: [%s]%s", prop_str.c_str(), hint.c_str());
#                    ESP_LOGI("ble_char", "");
#
#                } else if (elem.type == ESP_GATT_DB_DESCRIPTOR) {
#                    // --- Descriptor (z.B. CCCD für Notify) ---
#                    char uuid_str[64];
#                    if (elem.uuid.len == ESP_UUID_LEN_16) {
#                        snprintf(uuid_str, sizeof(uuid_str), "0x%04X", elem.uuid.uuid.uuid16);
#                    } else if (elem.uuid.len == ESP_UUID_LEN_128) {
#                        uint8_t *u = elem.uuid.uuid.uuid128;
#                        snprintf(uuid_str, sizeof(uuid_str),
#                            "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
#                            u[15],u[14],u[13],u[12],u[11],u[10],u[9],u[8],
#                            u[7],u[6],u[5],u[4],u[3],u[2],u[1],u[0]);
#                    }
#                    ESP_LOGD("ble_char", "    Descriptor: %s  Handle: 0x%04X", uuid_str, elem.attribute_handle);
#                }
#            }
#
#            ESP_LOGI("ble_char", "========================================");
#            ESP_LOGI("ble_char", "");
#            ESP_LOGI("ble_char", "############################################################");
#            ESP_LOGI("ble_char", "# Discovery abgeschlossen!");
#            ESP_LOGI("ble_char", "#");
#            ESP_LOGI("ble_char", "# Verwende die gefundenen UUIDs in deiner Haupt-Config:");
#            ESP_LOGI("ble_char", "#   service_uuid: <Service UUID mit WRITE+NOTIFY Chars>");
#            ESP_LOGI("ble_char", "#   char_tx_uuid: <UUID mit WRITE Property>");
#            ESP_LOGI("ble_char", "#   char_rx_uuid: <UUID mit NOTIFY Property>");
#            ESP_LOGI("ble_char", "############################################################");
#
#            free(db);
