# ============================================================
# ESPHome - Fiat Ducato 250 OBD2 via Veepeak OBDCheck BLE+
# Hardware: M5Stack ATOM S3 (ESP32-S3)
# ============================================================
#
# Funktionsweise:
#   1. ATOM S3 verbindet sich per BLE mit dem Veepeak ELM327
#   2. Sendet AT-Befehle + OBD2 PID-Abfragen über BLE-UART
#   3. Parst die Antworten via BLE text_sensor on_notify
#   4. Daten gehen per WiFi → ESPHome API → Home Assistant
#
# VOR DER NUTZUNG:
#   1. ducato-ble-scanner.yaml flashen → MAC + UUIDs ermitteln
#   2. Unten bei "substitutions" die korrekten Werte eintragen
#   3. WiFi-Daten + Passwörter in secrets.yaml eintragen
#
# Typische UUIDs für Veepeak OBDCheck BLE+:
#   Variante A (häufig): Service FFE0, Char FFE1
#   Variante B:          Service FFF0, Char FFF1
#   → Mit nRF Connect oder ducato-ble-scanner.yaml prüfen!
# ============================================================

# =============================================
# HIER ANPASSEN nach BLE-Scan!
# =============================================
substitutions:
  device_name: "ducato-obd2"
  friendly_name: "Ducato OBD2"
  # MAC-Adresse des Veepeak (aus BLE-Scanner Log)
  elm327_mac: "AA:BB:CC:DD:EE:FF"  # ← Deine Veepeak MAC-Adresse eintragen!
  # BLE Service UUID: 0xFFF0 (vom BLE-Scan + nRF Connect bestätigt)
  ble_service_uuid: "0000FFF0-0000-1000-8000-00805F9B34FB"
  # FFF1 = Notify (Antworten empfangen)
  ble_char_rx: "0000FFF1-0000-1000-8000-00805F9B34FB"
  # FFF2 = Write (Befehle senden)
  ble_char_tx: "0000FFF2-0000-1000-8000-00805F9B34FB"

esphome:
  name: ${device_name}
  friendly_name: "${friendly_name}"
  on_boot:
    priority: 600
    then:
      - lambda: |-
          id(elm_initialized) = false;
          id(current_pid_index) = 0;
          id(elm_response) = "";
          id(waiting_for_response) = false;

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: arduino

logger:
  level: DEBUG

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  ap:
    ssid: "Ducato-OBD2-Fallback"
    password: !secret ap_password

captive_portal:

web_server:
  port: 80

# --- Globale Variablen ---
globals:
  - id: elm_initialized
    type: bool
    initial_value: "false"
  - id: current_pid_index
    type: int
    initial_value: "0"
  - id: elm_response
    type: std::string
    initial_value: '""'
  - id: waiting_for_response
    type: bool
    initial_value: "false"

# --- BLE ---
esp32_ble_tracker:
  scan_parameters:
    active: true

ble_client:
  - mac_address: ${elm327_mac}
    id: elm327_ble
    on_connect:
      then:
        - logger.log: "BLE: Verbunden mit Veepeak OBDCheck BLE+"
        - delay: 1000ms
        - lambda: |-
            id(elm_initialized) = false;
            id(current_pid_index) = 0;
            id(elm_response) = "";
            id(waiting_for_response) = false;

        # --- ELM327 Initialisierung ---
        # Alle Befehle gehen an FFF2 (Write Characteristic)
        # ATZ - Reset
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x41, 0x54, 0x5A, 0x0D]  # "ATZ\r"
        - delay: 2000ms

        # ATE0 - Echo aus
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x41, 0x54, 0x45, 0x30, 0x0D]  # "ATE0\r"
        - delay: 500ms

        # ATL0 - Linefeed aus
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x41, 0x54, 0x4C, 0x30, 0x0D]  # "ATL0\r"
        - delay: 500ms

        # ATS0 - Spaces aus (kompaktere Antworten)
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x41, 0x54, 0x53, 0x30, 0x0D]  # "ATS0\r"
        - delay: 500ms

        # ATH0 - Headers aus
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x41, 0x54, 0x48, 0x30, 0x0D]  # "ATH0\r"
        - delay: 500ms

        # ATSP0 - Automatische Protokollerkennung
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x41, 0x54, 0x53, 0x50, 0x30, 0x0D]  # "ATSP0\r"
        - delay: 1000ms

        # 0100 - Erste OBD2-Abfrage um Protokoll-Erkennung auszulösen
        - ble_client.ble_write:
            id: elm327_ble
            service_uuid: ${ble_service_uuid}
            characteristic_uuid: ${ble_char_tx}
            value: [0x30, 0x31, 0x30, 0x30, 0x0D]  # "0100\r"
        - delay: 5000ms

        - lambda: |-
            id(elm_initialized) = true;
            ESP_LOGI("elm327", "Veepeak initialisiert - Auto-Protokoll");

    on_disconnect:
      then:
        - logger.log: "BLE: Veepeak getrennt!"
        - lambda: |-
            id(elm_initialized) = false;
            id(waiting_for_response) = false;

# --- OBD2 Template-Sensoren ---
sensor:
  - platform: template
    name: "Motortemperatur"
    id: coolant_temp
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:thermometer

  - platform: template
    name: "Drehzahl"
    id: engine_rpm
    unit_of_measurement: "RPM"
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:engine

  - platform: template
    name: "Geschwindigkeit"
    id: vehicle_speed
    unit_of_measurement: "km/h"
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:speedometer

  - platform: template
    name: "Motorlast"
    id: engine_load
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 1
    icon: mdi:gauge

  - platform: template
    name: "Ansauglufttemperatur"
    id: intake_temp
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:air-filter

  - platform: template
    name: "Kraftstoffstand"
    id: fuel_level
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 1
    icon: mdi:gas-station

  - platform: template
    name: "Drosselklappe"
    id: throttle_pos
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 1
    icon: mdi:car-cruise-control

  - platform: template
    name: "Batteriespannung"
    id: battery_voltage
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    icon: mdi:car-battery

  - platform: template
    name: "Ansaugkrümmerdruck"
    id: intake_map
    unit_of_measurement: "kPa"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:gauge-low

  - platform: template
    name: "Luftmassenmesser"
    id: maf_rate
    unit_of_measurement: "g/s"
    state_class: measurement
    accuracy_decimals: 2
    icon: mdi:weather-windy

  - platform: template
    name: "Motorlaufzeit"
    id: engine_runtime
    unit_of_measurement: "s"
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:timer-outline

  - platform: template
    name: "Motoröltemperatur"
    id: oil_temp
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:oil-temperature

  - platform: template
    name: "Umgebungstemperatur"
    id: ambient_temp
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:thermometer

  - platform: template
    name: "ECU Spannung"
    id: ecu_voltage
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    icon: mdi:flash

  - platform: template
    name: "Kraftstoffverbrauch"
    id: fuel_rate
    unit_of_measurement: "L/h"
    state_class: measurement
    accuracy_decimals: 2
    icon: mdi:fuel

  - platform: template
    name: "Barometrischer Druck"
    id: baro_pressure
    unit_of_measurement: "kPa"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 0
    icon: mdi:weather-partly-cloudy

  - platform: template
    name: "Abgasrückführung"
    id: egr_commanded
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 1
    icon: mdi:recycle

  # --- BLE Notification Empfänger ---
  # Empfängt Antworten vom ELM327 über FFF1 (Notify Characteristic)
  - platform: ble_client
    type: characteristic
    ble_client_id: elm327_ble
    id: elm327_notify_sensor
    name: "ELM327 Raw"
    internal: true
    service_uuid: ${ble_service_uuid}
    characteristic_uuid: ${ble_char_rx}
    notify: true
    update_interval: never
    lambda: |-
      // Rohdaten als String zusammenbauen und in elm_response puffern
      std::string chunk(x.begin(), x.end());
      ESP_LOGD("elm327", "Empfangen (raw): %s", chunk.c_str());
      id(elm_response) += chunk;

      // Prüfe ob Antwort komplett (ELM327 sendet '>' als Prompt)
      if (id(elm_response).find('>') == std::string::npos) {
        return {};  // Noch nicht komplett, kein Wert publizieren
      }

      // Komplette Antwort verarbeiten
      std::string full = id(elm_response);
      id(elm_response) = "";
      id(waiting_for_response) = false;

      // Bereinigen: Whitespace und Steuerzeichen entfernen
      std::string clean;
      for (char c : full) {
        if (c != ' ' && c != '\r' && c != '\n' && c != '>') {
          clean += c;
        }
      }

      ESP_LOGD("elm327", "Antwort: %s", clean.c_str());

      // Debug: Letzte Antwort als Text publizieren
      id(last_elm_response).publish_state(clean);

      // Fehler ignorieren
      if (clean.find("NODATA") != std::string::npos ||
          clean.find("ERROR") != std::string::npos ||
          clean.find("UNABLE") != std::string::npos ||
          clean.find("STOPPED") != std::string::npos) {
        ESP_LOGW("elm327", "Fehler/Keine Daten: %s", clean.c_str());
        return {};
      }

      // --- Fehlerspeicher (Mode 03, Antwort beginnt mit "43") ---
      if (clean.find("43") != std::string::npos) {
        size_t dpos = clean.find("43");
        std::string dtc_data = clean.substr(dpos);
        // Erstes Byte nach "43" = Anzahl DTCs, dann je 2 Bytes pro DTC
        // Format: 43 XX YY XX YY ... (ohne Anzahl-Byte bei manchen ELMs)
        std::string dtc_list;
        int dtc_count = 0;
        // DTCs starten ab Position 2 (nach "43"), je 4 Hex-Zeichen = 2 Bytes
        for (size_t i = 2; i + 3 < dtc_data.length(); i += 4) {
          std::string dtc_raw = dtc_data.substr(i, 4);
          if (dtc_raw == "0000") continue;  // Leer-Padding
          // Erstes Nibble bestimmt den DTC-Typ
          char first = dtc_raw[0];
          char prefix;
          switch (first) {
            case '0': case '1': case '2': case '3': prefix = 'P'; break;  // Powertrain
            case '4': case '5': prefix = 'C'; break;  // Chassis
            case '6': case '7': prefix = 'B'; break;  // Body
            case '8': case '9': case 'A': case 'B': prefix = 'U'; break;  // Network
            default: prefix = 'P'; break;
          }
          // Zweites Zeichen des DTC: erstes Nibble mod 4
          char second = '0' + (((first >= 'A' ? first - 'A' + 10 : first - '0') % 4));
          std::string dtc_code;
          dtc_code += prefix;
          dtc_code += second;
          dtc_code += dtc_raw.substr(1, 3);
          if (!dtc_list.empty()) dtc_list += ", ";
          dtc_list += dtc_code;
          dtc_count++;
        }
        if (dtc_count == 0) {
          id(active_dtcs).publish_state("Keine Fehler");
        } else {
          id(active_dtcs).publish_state(dtc_list);
        }
        ESP_LOGD("elm327", "DTCs (%d): %s", dtc_count, dtc_list.c_str());
        return {};
      }

      // --- Batteriespannung (ATRV Antwort, z.B. "12.4V") ---
      if (clean.find("V") != std::string::npos &&
          clean.find("41") == std::string::npos) {
        std::string volt_str;
        for (char c : clean) {
          if ((c >= '0' && c <= '9') || c == '.') {
            volt_str += c;
          }
        }
        if (!volt_str.empty()) {
          float voltage = atof(volt_str.c_str());
          if (voltage > 0 && voltage < 20) {
            id(battery_voltage).publish_state(voltage);
            ESP_LOGD("elm327", "Batterie: %.1f V", voltage);
          }
        }
        return {};
      }

      // --- OBD2 Antworten (Format: 41XXYY oder 41XXYYZZ) ---
      size_t pos = clean.find("41");
      if (pos == std::string::npos) return {};

      std::string data = clean.substr(pos);
      if (data.length() < 6) return {};

      auto hexByte = [](const std::string& s, int off) -> int {
        if (off + 2 > (int)s.length()) return -1;
        return (int)strtol(s.substr(off, 2).c_str(), nullptr, 16);
      };

      int pid = hexByte(data, 2);
      int a = hexByte(data, 4);
      int b = (data.length() >= 8) ? hexByte(data, 6) : 0;

      if (pid < 0 || a < 0) return {};

      switch (pid) {
        case 0x04:  // Motorlast: A*100/255
          {
            float load = (a * 100.0) / 255.0;
            id(engine_load).publish_state(load);
            ESP_LOGD("elm327", "Last: %.1f %%", load);
          }
          break;
        case 0x05:  // Kühlmitteltemperatur: A - 40
          id(coolant_temp).publish_state(a - 40);
          ESP_LOGD("elm327", "Kühlmittel: %d °C", a - 40);
          break;
        case 0x0B:  // Ansaugkrümmerdruck (MAP): A
          id(intake_map).publish_state(a);
          ESP_LOGD("elm327", "MAP: %d kPa", a);
          break;
        case 0x0C:  // Drehzahl: ((A*256)+B)/4
          {
            float rpm = ((a * 256) + b) / 4.0;
            id(engine_rpm).publish_state(rpm);
            ESP_LOGD("elm327", "Drehzahl: %.0f RPM", rpm);
          }
          break;
        case 0x0D:  // Geschwindigkeit: A
          id(vehicle_speed).publish_state(a);
          ESP_LOGD("elm327", "Speed: %d km/h", a);
          break;
        case 0x0F:  // Ansauglufttemperatur: A - 40
          id(intake_temp).publish_state(a - 40);
          ESP_LOGD("elm327", "Ansaugluft: %d °C", a - 40);
          break;
        case 0x10:  // MAF Luftmasse: ((A*256)+B)/100
          {
            float maf = ((a * 256) + b) / 100.0;
            id(maf_rate).publish_state(maf);
            ESP_LOGD("elm327", "MAF: %.2f g/s", maf);
          }
          break;
        case 0x11:  // Drosselklappe: A*100/255
          {
            float throttle = (a * 100.0) / 255.0;
            id(throttle_pos).publish_state(throttle);
            ESP_LOGD("elm327", "Drossel: %.1f %%", throttle);
          }
          break;
        case 0x1F:  // Motorlaufzeit: (A*256)+B Sekunden
          {
            float runtime = (a * 256) + b;
            id(engine_runtime).publish_state(runtime);
            ESP_LOGD("elm327", "Laufzeit: %.0f s", runtime);
          }
          break;
        case 0x2E:  // Abgasrückführung (AGR): A*100/255
          {
            float egr = (a * 100.0) / 255.0;
            id(egr_commanded).publish_state(egr);
            ESP_LOGD("elm327", "AGR: %.1f %%", egr);
          }
          break;
        case 0x2F:  // Kraftstoffstand: A*100/255
          {
            float fuel = (a * 100.0) / 255.0;
            id(fuel_level).publish_state(fuel);
            ESP_LOGD("elm327", "Kraftstoff: %.1f %%", fuel);
          }
          break;
        case 0x33:  // Barometrischer Druck: A
          id(baro_pressure).publish_state(a);
          ESP_LOGD("elm327", "Baro: %d kPa", a);
          break;
        case 0x42:  // ECU Spannung: ((A*256)+B)/1000
          {
            float volts = ((a * 256) + b) / 1000.0;
            id(ecu_voltage).publish_state(volts);
            ESP_LOGD("elm327", "ECU: %.3f V", volts);
          }
          break;
        case 0x46:  // Umgebungstemperatur: A - 40
          id(ambient_temp).publish_state(a - 40);
          ESP_LOGD("elm327", "Umgebung: %d °C", a - 40);
          break;
        case 0x5C:  // Motoröltemperatur: A - 40
          id(oil_temp).publish_state(a - 40);
          ESP_LOGD("elm327", "Öl: %d °C", a - 40);
          break;
        case 0x5E:  // Kraftstoffverbrauch: ((A*256)+B)/20
          {
            float rate = ((a * 256) + b) / 20.0;
            id(fuel_rate).publish_state(rate);
            ESP_LOGD("elm327", "Verbrauch: %.2f L/h", rate);
          }
          break;
        default:
          ESP_LOGD("elm327", "Unbekannter PID: 0x%02X", pid);
          break;
      }

      return {};

  # ESP32 Systemsensoren
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "Laufzeit"

binary_sensor:
  - platform: template
    name: "Motor läuft"
    id: engine_running
    lambda: |-
      return id(engine_rpm).has_state() && id(engine_rpm).state > 0;
    icon: mdi:engine

  - platform: template
    name: "ELM327 verbunden"
    id: elm_connected
    lambda: |-
      return id(elm_initialized);
    icon: mdi:bluetooth-connect

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "IP-Adresse"
    ssid:
      name: "WLAN"

  - platform: template
    name: "Letzte ELM327 Antwort"
    id: last_elm_response
    icon: mdi:message-text

  - platform: template
    name: "Aktive Fehlercodes"
    id: active_dtcs
    icon: mdi:alert-circle

# --- Zyklische OBD2-Abfragen ---
interval:
  - interval: 2s
    then:
      - if:
          condition:
            lambda: 'return id(elm_initialized) && !id(waiting_for_response);'
          then:
            - lambda: |-
                id(waiting_for_response) = true;
                id(elm_response) = "";
            - ble_client.ble_write:
                id: elm327_ble
                service_uuid: ${ble_service_uuid}
                characteristic_uuid: ${ble_char_tx}
                value: !lambda |-
                  const char* pid_cmds[] = {
                    "0105\r",   //  0: Kühlmitteltemperatur
                    "010C\r",   //  1: Drehzahl
                    "010D\r",   //  2: Geschwindigkeit
                    "0104\r",   //  3: Motorlast
                    "010F\r",   //  4: Ansauglufttemperatur
                    "012F\r",   //  5: Kraftstoffstand
                    "0111\r",   //  6: Drosselklappe
                    "ATRV\r",   //  7: Batteriespannung
                    "010B\r",   //  8: Ansaugkrümmerdruck (MAP)
                    "0110\r",   //  9: Luftmassenmesser (MAF)
                    "011F\r",   // 10: Motorlaufzeit
                    "015C\r",   // 11: Motoröltemperatur
                    "0146\r",   // 12: Umgebungstemperatur
                    "0142\r",   // 13: ECU Spannung
                    "015E\r",   // 14: Kraftstoffverbrauch
                    "0133\r",   // 15: Barometrischer Druck
                    "012E\r",   // 16: Abgasrückführung (AGR)
                    "03\r",     // 17: Fehlerspeicher auslesen (Mode 03)
                  };
                  const int num_pids = 18;
                  int idx = id(current_pid_index) % num_pids;
                  std::string cmd = pid_cmds[idx];
                  ESP_LOGD("elm327", "PID[%d] gesendet: %s", idx, pid_cmds[idx]);
                  id(current_pid_index) = (idx + 1) % num_pids;
                  return std::vector<uint8_t>(cmd.begin(), cmd.end());

  # Timeout: Falls keine Antwort kommt, nach 5s Reset
  - interval: 5s
    then:
      - lambda: |-
          if (id(waiting_for_response)) {
            ESP_LOGW("elm327", "Antwort-Timeout, mache weiter...");
            id(waiting_for_response) = false;
            id(elm_response) = "";
          }
